[
  {
    "answer": "\n\nПростота логической структуры (все данные логически структурированы внутри отношений).\nНебольшой набор абстракций (которые позволяют просто моделировать большинство ПрО и допускают точные формальные определения, оставаясь интуитивно понятными).\nПростой, но мощный математический аппарат (опирающийся в основном на теорию множеств и математическую логику)\nВозможность спецификационного манипулирования без необходимости знания физической схемы.\n\n",
    "question": "Укажите основные достоинства реляционного подхода к моделированию данных",
    "question_number": 1
  },
  {
    "answer": "\nТип данных - понятие, аналогичное понятию в языках программирования (т.е. множество значений и операций над ними)\nДомен - множество допустимых значений данного типа.\nАтрибут - именованный домен, представляющий семантически значимые объекты.\nКортеж – набор именованных значений заданных типов (это множество пар «имя атрибута, значение», которое содержит одно вхождение каждого имени атрибута, принадлежащего схеме отношения).\nОтношение - множество кортежей, соответствующих одной схеме отношения.\n\nДополнительно:\nСхема отношения – это именованное множество пар «имя атрибута, имя домена».\nСхема БД – это набор именованных схем отношений.\nМощность множества - степень схемы отношения\nРеляционная база данных – это набор отношений, имена которых совпадают с именами схем отношений в схеме БД.\n\n",
    "question": "Перечислите и дайте определения основных структурных понятий реляционной модели",
    "question_number": 2
  },
  {
    "answer": "\nОтсутствие кортежей-дубликатов\nОтсутствие упорядоченности кортежей и атрибутов\nАтомарность значений атрибутов\n(Атомарный атрибут - атрибут, теряющий смысл при любом разбиении на части)??\n",
    "question": "Какие свойства характерны для отношений реляционной модели",
    "question_number": 3
  },
  {
    "answer": "\nМножества сущностей становятся отношениями, однозначные атрибуты множеств сущностей - атрибутами отношений, ключи сущностей - возможными ключами отношения.\nСвязи 1:1 и 1:М без атрибутов представляются дублированием первичного ключа отношения, у которого стоит единица в диаграмме, в другое. В случае множества связей типа 1:1 выбор M-отношения осуществляется произвольным образом.\nСвязи М:N без атрибутов становятся отношениями, куда дублируются первичные ключи отношений, участвующих в связи.\nМножества связей с атрибутами становятся самостоятельными отношениями, куда дублируются первичные ключи отношений, построенных для множеств сущностей. Однозначные атрибуты множества связей становятся атрибутами этого отношения.\nСвязи с атрибутами и связи степени больше двух становятся отношениями, куда дублируются первичные ключи отношений, участвующих в связи. Однозначные атрибуты множества связей становятся атрибутами отношения.\nМногозначные атрибуты множеств сущностей или связей становятся отдельными отношениями, куда дублируется первичный ключ отношения, построенного для этого множества сущностей или связей.\n\n\n\n",
    "question": "Сформулируйте простейшие правила перехода от ER схемы Чена к реляционной схеме БД",
    "question_number": 4
  },
  {
    "answer": "\nПредставление - виртуальное отношение, кортежи (или экстенсионал) которого не хранятся на диске, а воспроизводятся на основании базовых отношений, реально существующих в БД.\nПредназначены для\nСокрытия некоторых частей БД от определенных пользователей\nОрганизации доступа пользователей к БД удобным для них образом\nУпрощения сложных операций с базовыми отношениями.\nСоздаются командой CREATE VIEW.\n\n",
    "question": "Что такое представление и для чего они предназначены Какой командой SQL они создаются",
    "question_number": 5
  },
  {
    "answer": "\nНа значения атрибутов (указывать тип данных и условия на значения атрибутов - CHECK, datatype)\nНа отображения между атрибутами одного отношения (PRIMARY KEY)\nНа отображения между отношениями (FOREIGN KEY)\n\n",
    "question": "Какие типы ограничений целостности можно декларативно задать в командах языка SQL",
    "question_number": 6
  },
  {
    "answer": "\nNULL и NOT NULL (может ли атрибут иметь неопределенное значение), PRIMARY KEY (первичный ключ), UNIQUE (возможный ключ), FOREIGN KEY (внешний ключ), CHECK (условие на значение атрибутов).\n\n",
    "question": "Перечислите конструкции языка SQL связанные с ограничениями целостности",
    "question_number": 7
  },
  {
    "answer": "Неопределенное значение (NULL) указывает, что значение атрибута сейчас неизвестно или неприемлемо для кортежа.\nНе принадлежит никакому типу данных и может присутствовать среди значений любого атрибута.\nПри выполнении двуместных операций с другими значениями некоторого типа данных (например, сложение) дает неопределенное значение, при сравнении значений дает unknown.\n\nUnknown - третье значение логического типа, обладающее свойствами: (для удобства запоминания можно представлять unkn0wn = 0.5, true = 1, false = 0)\nNOT unkn0wn = unkn0wn\ntrue AND unkn0wn = unkn0wn\ntrue OR unkn0wn = true\nfalse AND unkn0wn = false\nfalse OR unkn0wn = unkn0wn.\n\n",
    "question": "Что такое неопределенное значение и логическое значение unknown Какими свойствами они обладают",
    "question_number": 8
  },
  {
    "answer": "Требование целостности сущностей (любые два кортежа одного отношения должны быть отличимы). Обеспечивается тем, что у любого отношения должен быть первичный ключ (UNIQUE и NOT NULL).\nДостаточно гарантировать отсутствие отношений, содержащих кортежи с одним и тем же значением первичного ключа\nЗапрещать вхождение в значение первичного ключа неопределенных значений\nТребование целостности по ссылке (для каждого значения внешнего ключа должен найтись кортеж с таким же значением первичного ключа, либо значение внешнего ключа должно быть неопределенным). Обеспечивается следующим Побразом:\nДостаточно следить за тем, чтобы не появлялись некорректные значения внешнего ключа;\nПри удалении кортежа из отношения, на которое ведет ссылка, либо запрещается его удаление, пока не будут удалены все ссылки, либо автоматически значения всех ссылок становятся неопределенными, либо автоматически удаляются все кортежи, ссылающиеся на удаляемый.\n\n",
    "question": "Укажите два основных правила целостности реляционной модели Как они обеспечиваются",
    "question_number": 9
  },
  {
    "answer": "\nСуперключ - атрибут или их множество, единственным образом идентифицирующее кортеж отношения.\nПотенциальный ключ - суперключ, никакое подмножество которого не является суперключом.\nСоставной ключ - ключ, состоящий из нескольких атрибутов.\nПервичный ключ - потенциальный ключ, выбранный для уникальной идентификации кортежей отношения.\nАльтернативный ключ - потенциальный ключ, не выбранный в качестве первичного.\nСуррогатный ключ - искусственный атрибут, не имеющий связей с реальными характеристиками явлений ПрО, вводимый в схему отношения исключительно для организации связи кортежей.\n\n",
    "question": "Дайте определения суперключа потенциального ключа составного ключа первичного ключа альтернативного ключа суррогатного ключа? Как они соотносятся друг с другом?",
    "question_number": 10
  },
  {
    "answer": "\nСуррогатный первичный ключ - первичный ключ, уникальные значения которого генерируются СУБД.\nПреимущества по сравнению с естественными первичными ключами:\nЕдинообразие всех суррогатных ключей отношений (обычно имена строятся одинаково, а ключи имеют один тип значений)\nКомпактность суррогатных ключей\nОтсутствие потребности в изменениях, которые могут затронуть много отношений схемы (т.е. ошибка в значении первичного ключа не распространяется в другие отношения, где он является внешним).\n\n",
    "question": "Что такое суррогатный первичный ключ? Почему в последнее время проектировщики предпочитают использовать только их?",
    "question_number": 11
  },
  {
    "answer": "\nВнешний ключ - атрибут отношения или множество атрибутов, соответствующее потенциальному ключу некоторого отношения и являющееся его подмножеством.\nСам внешний ключ не должен обладать свойством уникальности, им должен обладать потенциальный ключ.\nИспользуется для осуществления связи отношений (если некий атрибут присутствует в нескольких отношениях, то его наличие обычно отражает определенную связь между кортежами этих отношений)\n\n\"внешний ключ должен являться подмножеством значений атрибутов на которые он ссылается\"\n",
    "question": "Что такое внешний ключ? Должен ли он обладать свойством уникальности? Для чего и как он используется?",
    "question_number": 12
  },
  {
    "answer": "schema – имя схемы, в которой создается таблица (по умолчанию используется схема пользователя).\ntable – имя создаваемой таблицы.\ncolumn – имя столбца. DEFAULT - значение столбца по умолчанию.\ndatatype – тип данных столбца (CHAR, NUMBER, DATE, BLOB, LONG…)\ninline_constraint - ограничение целостности на уровне столбца.\nout_of_line_constraint - ограничение целостности на уровне таблицы.\nconstraint_name – уникальное имя ограничения целостности. (NULL, NOT NULL, UNIQUE, PRIMARY KEY, references_clause, CHECK)\nreferences_clause - ограничение ссылочной целостности для внешнего ключа таблицы.\n\n",
    "question": "Укажите основные компоненты команды SQL CREATE TABLE. Приведите примеры",
    "question_number": 13
  },
  {
    "answer": "\nТриггер – это программа на языке программирования сервера, которая автоматически выполняется СУБД в момент наступления определенного события.\nПредназначение:\nПроверка правильности введенных данных и проверка выполнения ограничений целостности данных\nОсуществление косвенных модификаций данных\nВыдача предупреждений, напоминающих о необходимости что-то выполнить\nНакопление информации аудита посредством фиксации сведений о внесенных изменениях и о лицах, внесших изменения\n\n\n",
    "question": "Что такое триггер Для чего они предназначены Процедурный способ определения ограничений целостности",
    "question_number": 14
  },
  {
    "answer": "\nоператоры INSERT, UPDATE или DELETE, применяемые к указанной таблице\nоператоры CREATE, ALTER или DROP, применяемые к любому объекту схемы;\nзапуск базы данных\nФакторы, влияющие на запуск:\nрегистрация пользователя в системе или выход из нее;\nконкретное или любое сообщение об ошибке.\nтриггеры могут также активизировать друг друга.\n",
    "question": "При каких событиях в системе БД могут запускаться триггеры? Какие факторы влияют на запуск триггеров обновления данных?(4.2.1., стр. 23)",
    "question_number": 15
  },
  {
    "answer": "\nТриггеры для таблиц отличаются от триггеров для представлений использованием основных команд SQL CREATE TRIGGER:\nBEFORE, AFTER - нельзя использовать в триггерах для представлений (Before: в теле триггера можно изменять NEW-значения и нельзя изменять OLD-значения столбцов; After: в теле триггера нельзя изменять ни NEW-значения, ни OLD-значения столбцов.);\nINSTEAD OF - нельзя использовать в триггерах для таблиц; в теле триггера можно читать (в теле триггера можно читать NEW-значения и OLD-значения и нельзя изменять ни NEW-значения, ни OLD-значения столбцов.)\n NEW-значения и OLD-значения используются  для модификации представлений.\n\n",
    "question": "Чем отличаются триггеры для таблиц от триггеров для представлений?",
    "question_number": 16
  },
  {
    "answer": "\nС помощью ключевых слов NEW и OLD\nКлючевое слово NEW в теле триггера используется для ссылки на новое значение столбца\nКлючевое слово OLD может быть использовано для ссылки на старое значение столбца.\nСинтаксис обращений  {NEW|OLD}.{имя столбца}.\n\n",
    "question": "Как в коде триггера можно ссылаться на значения столбцов модифицируемых строк? (4.2.1, стр. 24)",
    "question_number": 17
  },
  {
    "answer": "\nИсполнение табличного триггера BEFORE на уровне оператора.\nДля каждой строки, охваченной данным оператором:\nисполнение любого триггера BEFORE на уровне строки;\nблокировка данных и выполнение над ними действия, предписанного командой SQL\nвыполнение проверок ограничений целостности;\nисполнение любого триггера AFTER на уровне строки.\nИсполнение табличного триггера AFTER на уровне оператора.\n",
    "question": "Какова последовательность выполнения триггеров и основного действия с данными? (4.2.1, стр. 24)",
    "question_number": 18
  },
  {
    "answer": "\nschema – имя схемы, в которой создается триггер\ntrigger – имя триггера.\nвремя выполнения триггера:\nBEFORE (до выполнения основного действия),\nAFTER (после выполнения основного действия),\nINSTEAD OF (вместо выполнения основного действия).\ndml_event_clause определяет грамматику триггеров для команд языка манипулирования данными. Команды, указывающие на то, для чего будет выполняться триггер:\nDELETE  (для удаления строк таблицы),\nINSERT (для добавления строк в таблицу),\nUPDATE (для модификации строк таблицы),\nFOR EACH ROW (определяет является ли триггер строковым. Если эта фраза опущена, триггер является операторным).\nON указывает на имя таблицы, на изменения в которой будет реагировать триггер.\nWHEN определяет дополнительное условие, при истинности которого будет выполняться триггер.\npl/sql_block определяет блок PL/SQL, который выполняется, когда триггер активизируется\n\n",
    "question": "Назовите основные компоненты команды SQL CREATE TRIGGER. Приведите примеры.",
    "question_number": 19
  },
  {
    "answer": "Особенность: построчное считывание информации при помощи циклов\nИспользуется: исключительно в интерфейсах с реляционными СУБД.\nВсе эти интерфейсы строятся по принципу:\n1) СУБД передается запрос на выборку данных\n2) В памяти программы отводится место - для размещения значений, который считываются из текущей строки\n3) Затем происходит построчное сканирование результирующей выборки с чтением и обработкой следующих данных одной строки.\nПРОГРАММОЙ - интрефейсы\n",
    "question": " Каковы основные особенности навигационного стиля манипулирования реляционными данными? Когда используется навигационный стиль манипулирования реляционными данными? (4.2.1, стр. 28)",
    "question_number": 20
  },
  {
    "answer": "Курсор - инструмент для построчного сканирования результирующих таблиц с данными.\nКурсоры бывают:\nНеявные - организуются системой неявно для всех команд SQL, если они селектируют и выполняют некоторые действия с одной строкой.\nЯвные - объявляются в области объявлений, если селектируют и выполняют действия над множеством строк.\n\n",
    "question": "Что собой представляют курсоры PL/SQL?",
    "question_number": 21
  },
  {
    "answer": "\nОбъявление курсора начинается с ключевого слова CURSOR.\nКоманды OPEN и CLOSE работают как скобки, внутри которых курсор активен и может использоваться для сканирования данных.\nЧтение строк командой OPEN не производится, для этого предназначена команда FETCH.\nКонструкция BULK COLLECT команды FETCH позволяет за одно обращение к ней прочитать целиком все столбцы результирующей таблицы в соответствующие коллекции, типы данных которых соответствуют типам данных столбцов.\nКоманды LOOP и END LOOP образуют безусловный цикл.\n\n\n",
    "question": " Какие команды предусмотрены в языке PL/SQL для объявления и обращения к курсорам?(4.2.1, стр. 29-30)",
    "question_number": 22
  },
  {
    "answer": "Каждый явный курсор имеет четыре атрибута – ISOPEN, FOUND, NOTFOUND, ROWCOUNT. Они возвращают полезную информацию о выполнении обращений к данным результирующей таблицы. Их следует использовать для адекватной обработки ситуаций, связанных с курсором.\nISOPEN возвращает значение TRUE, если курсор открыт, FALSE – в противном случае.\nFOUND принимает значение NULL, если курсор открыт, но команды FETCH для него не выполнялись, TRUE, если последняя команда FETCH прочитала данные из текущей строки и FALSE, если очередной FETCH вышел за границу курсора.\nNOTFOUND отличается от FOUND тем, что он возвращает TRUE, когда FOUND дает FALSE и наоборот. В остальных случаях реакция аналогична.\nROWCOUNT равен нулю сразу после открытия курсора и числу строк результирующей таблицы, прочитанных до этого командами FETCH в процессе сканирования.\nкодда\n",
    "question": " Как управлять процессом обращений к курсору с помощью атрибутов курсора?",
    "question_number": 23
  },
  {
    "answer": "1) Алгебраические языки, позволяющие выражать запросы средствами\nспециализированных операторов, применяемых к отношениям.\n2) Языки исчисления предикатов, в которых запросы описывают требуемое\nмножество кортежей путем указания логического выражения, которому\nдолжны удовлетворять эти кортежи. Делятся на:\nязыки реляционного исчисления с переменными-кортежами (ALPHA)\nязыки реляционного исчисления с переменными на доменах (QBE)\n3) SQL-подобные языки. Каждая конструкция SELECT этих языков задает отображение строк исходных таблиц в строки результирующей таблицы.\n\n \n",
    "question": " Укажите и охарактеризуйте классы спецификационных языков реляционной модели.",
    "question_number": 24
  },
  {
    "answer": "\nЗапрос в процедурных языках - представляет алгоритм получения результата, а в декларативных языках - представляет собой некоторый образец или условие по которым необходимо найти требуемые данные.\nНавигационные языки всегда процедурны.\n\n",
    "question": " Поясните деление языков на процедурные и декларативные.(4.2.4, стр. 2)",
    "question_number": 25
  },
  {
    "answer": "Основные:\nОбъединение (UNION) - множество кортежей, которые принадлежат одному из отношений, либо им обоим.\nРазность (MINUS) - множество кортежей, принадлежащих одному отношению, но не принадлежащих второму.\nДекартово произведение отношений (TIMES) - множество всех кортежей степени k1+k2, где первые k1 компонентов которых образуют кортежи, принадлежащие первому отношению, а последние k2 – кортежи, принадлежащие второму отношению.\nПроекция (PROJECT) - берется отношение, удаляются некоторые из его атрибутов и (или) переупорядочиваются оставшиеся атрибуты.\nСелекция (SELECT) - множество кортежей, принадлежащих отношению, таких, что при подстановке i-го компонента кортежа вместо всех вхождений номера i в формулу F для всех i она станет истинной. Наряду с номерами в операциях селекции можно использовать имена атрибутов\n\nДополнительные:\nПересечение (INTERSECT) - множество кортежей, которые одновременно принадлежат обоим отношениям.ER\nЧастное (DIVIDE) - множество кортежей t длины (r - s), таких, что для всех кортежей u длины s, принадлежащих S, кортеж t конкатенация u принадлежит R.\nСоединение (JOIN). Ө-соединение (тета) (Ө-JOIN) Ө-соединение отношений представляет собой множество таких кортежей их декартова произведения, что i-ый компонент первого отношения находится в отношении Ө с j-ым компонентом второго. Если Ө является оператором «равно» («=»), эта операция  часто называется эквисоединением (EQUIJOIN).\n\n\n",
    "question": " Дайте определение основных и дополнительных операций реляционной алгебры Кодда Поясните на примерах их работу. (4.2.4, стр. 3-5, примеры на стр. 6-7)",
    "question_number": 26
  },
  {
    "answer": "Естественное соединение (INNER JOIN) - эквисоединение, из результата которого исключены по одному экземпляру из каждой пары совпадающих атрибутов (атрибуты группы X или группы Y). То есть, в результате будет исключен один экземпляр из каждой пары совпадающих атрибутов (атрибуты группы Х или Y)\nКомпозиционное соединение (COMPOSITE JOIN) - эквисоединение, при котором атрибуты соединения (атрибуты групп X и Y) не включаются в результат. Такое соединение уместно при использовании для связей кортежей суррогатных ключей.\nЛевое внешнее соединение (LEFT OUTER JOIN) - соединение, при котором к результату эквисоединения добавляются кортежи левого операнда, не вошедшие в эквисоединение, конкатенированные справа с заполненными NULLами кортежами.\nПравое внешнее соединение (RIGHT OUTER JOIN) - соединение, при котором к результату эквисоединения добавляются кортежи правого операнда, не вошедшие в эквисоединение, конкатенированные слева с заполненными NULLами кортежами.\nРезультат полного внешнего соединения (FULL OUTER JOIN) совпадает с объединением левого и правого внешних соединений. Ничего не исключается из результата.\n\n\n\n",
    "question": " Проведите на конкретном примере сравнительный анализ всех разновидностей операции соединения. ",
    "question_number": 27
  },
  {
    "answer": "\nДействие включения выполняется операцией UNION\nДействие удаления - операцией MINUS\nДействие модификации сводится к действию удаления и последующего включения.\nВо всех этих случаях первым операндом и результатом является изменяемое базовое отношение.\nА вторым операндом является либо производное отношение, полученное запросом выборки, либо отношение, кортежи которого заданы явным указанием их компонентов.\n\n(Язык реляционной алгебры обычно не используют для изменения состояния БД, однако действия включения, модификации и удаления кортежей можно выполнить и в этом языке)\n",
    "question": " Как в языке реляционной алгебры выполняются действия изменяющие состояние БД? (4.2.4, стр. 10)",
    "question_number": 28
  },
  {
    "answer": "\n{t|ψ(t)} (t такое, что “пси” от t), где t – переменная-кортеж (переменная, обозначающая кортеж некоторой фиксированной длины), а ψ (пси) – формула, построенная из атомов и совокупности операторов.\nВажное дополнительное условие: указанная конструкция являлась запросом реляционного исчисления\n\n",
    "question": " Какой вид имеют запросы в реляционном исчислении с переменными кортежами? (4.2.4, стр. 11)",
    "question_number": 29
  },
  {
    "answer": "\nАтомы формул ψ (пси) (реляционного исчисления) могут быть трех типов:\nR(s), где R – имя отношения, а s – переменная-кортеж. Этот атом принимает значение «истина», когда s есть кортеж отношения R.\ns[i] Ө (тета) u[j], где s и u являются переменными-кортежами, а Ө – оператор сравнения. Этот атом принимает значение «истина», когда i-ый компонент s находится в отношении Ө с j-ым компонентом u.\ns[i] Ө a - где Ө – оператор сравнения, s[i]-переменные-кортежа, a – это константа. Этот атом принимает значение «истина», когда i-ый компонент s находится в отношении Ө с константой a.\n\n",
    "question": " Укажите разновидности атомов формул реляционного исчисления с переменными кортежами. (4.2.4, стр. 11)",
    "question_number": 30
  },
  {
    "answer": "\n1. Каждый атом есть формула. Все вхождения переменных-кортежей, упомянутые в атоме, являются свободными в этой формуле.\n2. Если ψ1 и ψ2 – формулы, то “пси1 или пси2”, “пси1 и пси2”, “не пси1” – тоже формулы\n3. Если ψ – формула, в которой есть свободная переменная s, то “существует s от пси” и “любое s от пси” – также формулы.\n4. Формулы могут заключаться в круглые скобки для изменения приоритета операторов. Приоритет: 1) оператор сравнения, 2) ∃/∀, 3) отрицание, 4) и, 5) или.\n5. Ничто иное не является формулой.\n\n",
    "question": " Перечислите правила построения формул реляционного исчисления с переменными кортежами. (4.2.4, стр. 12)",
    "question_number": 31
  },
  {
    "answer": "\nВхождение переменной в формулу является «связанным», если этой переменной предшествует квантор «для всех» или «существует». Иначе - переменная свободная.\n\n",
    "question": " Как определяется статус связана свободна переменных кортежей? (4.2.4, стр. 11)",
    "question_number": 32
  },
  {
    "answer": "\nЗапросы в реляционном исчислении с переменными на доменах имеют вид\n(читается так: х1, х2 такие, что пси от х1, х2) где x1, x2, …, xk – переменные на доменах, т.е. переменные, обозначающие скалярные значения, взятые из определенных доменов, а ψ – формула, построенная из атомов и совокупности операторов\n\n",
    "question": " Какой вид имеют запросы в реляционном исчислении с переменными на доменах? (4.2.4, стр. 20)",
    "question_number": 33
  },
  {
    "answer": "Атомы формул пси могут быть двух типов:\nR(x1 x2 … xk), где R – имя отношения степени k, а каждое xi есть константа или переменная на домене. Этот атом принимает значение «истина», когда x1 x2 … xk есть кортеж отношения R.\nx Ө (тета) y, где x и y являются константами или переменными на доменах, а Ө – оператор сравнения. Этот атом принимает значение «истина», когда x находится в отношении Ө с y.\n\n",
    "question": " Укажите разновидности атомов формул реляционного исчисления с переменными на доменах. (4.2.4, стр. 20)",
    "question_number": 34
  },
  {
    "answer": "\n1. Каждый атом есть формула.\n2. Если ψ1 и ψ2 – формулы, то “пси1 или пси2”, “пси1 и пси2”, “не пси1” – тоже формулы\n3. Если ψ – формула, в которой есть свободная переменная s, то “существует s от пси” и “любое s от пси” – также формулы.\n4. Формулы могут заключаться в круглые скобки для изменения приоритета операторов. Приоритет: оператор сравнения, ∃/∀, отрицание, и, или.\n5. Ничто иное не является формулой.\n\n",
    "question": " Перечислите правила построения формул реляционного исчисления с переменными на доменах. (4.2.4, стр. 20-21)",
    "question_number": 35
  },
  {
    "answer": "\nВхождение переменной в формулу является «связанным», если этой переменной предшествует квантор «для всех» или «существует». Иначе - свободной.\n(читается так: х1, х2 такие, что пси от х1, х2)\nИЛИ:   где x1, …, xk – свободные переменные на доменах в формуле\n\nФормулы, а также свободные и связанные вхождения переменных на доменах в этих формулах определяются рекурсивно следующим образом.\nКаждый атом есть формула. Все вхождения переменных на доменах, упомянутые в атоме, являются свободными в этой формуле.\nЭкземпляры переменных на доменах не меняют своего статуса «связана-свободна» в новых формулах.\nЕсли ψ – формула, в которой есть свободная переменная x, то ∃x (ψ) – также формула. Символ «∃» представляет собой квантор существования.\nВхождения переменной x, свободные в формуле ψ, становятся связанными этим квантором в новой формуле. Остальные вхождения переменных на доменах, включая возможные вхождения x, связанные в ψ, своего статуса не меняют.\nЕсли ψ – формула, в которой есть свободная переменная x, то ∀x (ψ) – также формула. Символ «∀» представляет собой квантор всеобщности. Вхождения переменной x, свободные в формуле ψ, становятся связанными этим квантором в новой формуле. Остальные вхождения переменных на доменах, включая возможные вхождения x, связанные в ψ, своего статуса не меняют\n\n",
    "question": " Как определяется статус связана свободна переменных на доменах?",
    "question_number": 36
  },
  {
    "answer": "\nОриентация на диалоговое взаимодействие человека с системой БД.\nДвумерный синтаксис команд. (Поскольку операции задаются в табличной форме, говорят, что QBE имеет двумерный синтаксис)\nМинимум вводимых человеком символов.\nОбъединение в одном и том же синтаксисе функциональности всех языков системы БД (языка определения данных, языка манипулирования данными, языка определения ограничений целостности, языка безопасности данных).\nМощная и в то же время бескванторная «человеческая» логика.\n\n",
    "question": " Перечислите основные отличительные особенности языка QBE (4.2.4, стр. 21)",
    "question_number": 37
  },
  {
    "answer": "\nЛевое верхнее поле - идентификация отношения (таблицы) и действий с ним. (Действие с отношениями)\nОстальные поля заголовка - идентификация атрибутов и действий с ними.\n(Действие с атрибутами)\nПоля первого столбца (кр. верхнего) - действия с кортежами.\nПоля тела - действия с отдельными компонентами кортежей.\n\n",
    "question": " Какие группы полей выделяются в таблице шаблоне QBE К каким элементам БД они относятся?",
    "question_number": 38
  },
  {
    "answer": "\nПредлагается пустой шаблон таблицы.\nПользователь заполняет поле в левом верхнем углу именем таблицы. Поля шапки таблицы, за исключение левого, могут заполниться автоматически.\nПосле этого пользователь формулирует запрос, например\n\nПосле того как запрос сформулирован, пользователь нажимает клавишу Enter для получения ответа.\nЕсли необходимы две или более таблиц, можно сформировать дополнительные пустые шаблоны (используя специальные функциональные клавиши) и затем ввести информацию в их заголовки.\nУсловия, заданные в одной строке, связываются конъюнкцией. Для дизъюнкции условий их нужно указать в разных строках.\nПорядок строк в запросах несущественен.\n\n",
    "question": " Опишите на примере последовательность совместных действий пользователя и системы по формулированию запроса QBE (Query by example).",
    "question_number": 39
  },
  {
    "answer": "\nЯзык допускает три конструкции, начинающиеся со слова SELECT:\nСпецификация курсора\nОператор выборки\nПодзапрос.\nКурсор позволяет\nС помощью набора специальных операторов получить построчный доступ к результату запроса к БД.\nОсобенность: К табличным выражениям не предъявляются какие-либо ограничения.\nОператор выборки позволяет\nполучить результат запроса в прикладной программе без использования курсора. Особенность: Ограничения - результирующая таблица должна содержать не более одной строки.\nПодзапрос - запрос, который может входить в предикат условия выборки оператора SQL.\nОсобенности: Ограничение - результирующая таблица должна содержать в точности один столбец. Вместо констант разделов WHERE и HAVING можно использовать значения столбцов текущих строк таблиц внешних запросов.\n\n",
    "question": " Какие различные синтаксические конструкции с ключевым словом SELECT предусмотрены в стандарте SQL Для каких ситуаций использования они предназначены? В чем особенности каждой конструкции?",
    "question_number": 40
  },
  {
    "answer": "\nСемантика табличного выражения состоит в том, что на основе последовательного применения разделов from, where, group by и having из заданных в разделе from таблиц строится некоторая новая результирующая таблица, порядок следования строк которой не определен и среди строк которой могут находиться дубликаты.\n\nFROM: Результатом выполнения является расширенное декартово произведение таблиц, заданных списком таблиц раздела FROM.\nWHERE: Результатом является таблица, состоящая из тех строк, для которых результатом вычисления условия поиска является true.\nGROUP BY: Результатом является разбиение отношения на множество групп строк, в которых для каждого столбца из списка столбцов раздела GROUP BY во всех строках каждой группы, значения этого столбца совпадают.\nHAVING: Результатом выполнения является сгруппированная таблица, содержащая только те группы строк, для которых результат вычисления условия поиска есть true.\n\n",
    "question": " В чем заключается основная семантика табличного выражения команды SELECT Из каких разделов она состоит и для чего предназначен каждый раздел? (4.2.4, стр. 40, 44)",
    "question_number": 41
  },
  {
    "answer": "\nFROM -> WHERE (если есть) -> GROUP BY (если есть) -> HAVING (если есть)\nЕсли табличное выражение содержит только раздел FROM (это единственный обязательный раздел табличного выражения), то результат табличного выражения совпадает с результатом раздела FROM.\nЕсли присутствует раздел WHERE, то далее вычисляется он.\nЕсли присутствует раздел GROUP BY, то далее выполняется он.\nПоследним выполняется раздел HAVING (если он присутствует).\n\n",
    "question": " Опишите в целом алгоритм вычисления табличного выражения команды SELECT.",
    "question_number": 42
  },
  {
    "answer": "\nЗначение выражения неопределено, если в его вычислении участвует хотя бы одно неопределенное значение.\nВ контексте GROUP BY, DISTINCT и ORDER BY неопределенное значение выступает как специальный вид определенного значения, т.е. возможно образование группы строк, значение указанного столбца которых является неопределенным.\nБулевские операции AND, OR и NOT работают в трехзначной(true, false и unknown) логике следующим образом:\n(для удобства запоминания можно представлять unkn0wn = 0.5, true = 1, false = 0)\ntrue AND unkn0wn = unkn0wn,\nfalse AND unkn0wn = false,\nunkn0wn AND unkn0wn = unkn0wn,\ntrue OR unkn0wn = true\nfalse OR unkn0wn = unkn0wn,\nunkn0wn OR unkn0wn = unkn0wn,\nNOT unkn0wn = unkn0wn\n\n\n\n\n",
    "question": " Каковы особенности использования неопределенных значений атрибутов и логического значения unknown в запросах SQL?",
    "question_number": 43
  },
  {
    "answer": "\n(для удобства запоминания можно представлять unknown = 0.5, true = 1, false = 0)\n(таблицу читать надо так:\n“Предикат <имя предиката> примет значение <true, false, unknown>, если <текст на месте пересечения имени предиката и принимаемого значения>”)\n\nПредикат\ntrue\nfalse\nunknown\n предикат сравнения\nсравнение верно\n(4 < 5)\nсравнение неверно\n(5 < 4)\nхотя бы один из операндов имеет неопред. значение или правый операнд - подзапрос с пустым результатом\nпредикат between\nоба из предикатов сравнения верны\nодин из предикатов сравнения неверен\nодин из предикатов сравнения имеет неопред. значение\nпредикат in\nзначение левого операнда совпадает с одним из значений списка правого операнда\nсписок правого операнда пуст или значение левого операнда не совпадает ни с одним значением из списка правого операнда\nв остальных случаях (напр., значение левого операнда равно NULL)\nпредикат  like\nзначение указанного столбца удовлетворяет заданному шаблону\nзначение указанного столбца НЕ удовлетворяет заданному шаблону\nзначение шаблона или столбца неопределено\nпредикат  is null\nуказанное значение неопределено\nуказанное значение определено\nникогда\nпредикат  с квантором ALL\nрезультат вычисления подзапроса пуст, или значение предиката верно для каждого элемента подзапроса\nзначение предиката неверно хотя бы для одного элемента подзапроса\nв остальных случаях\nпредикат  с квантором SOME\nзначение предиката верно хотя бы для одного элемента подзапроса\nрезультат вычисления подзапроса пуст или значение предиката неверно для каждого элемента подзапроса\nв остальных случаях\nпредикат  exists\nрезультат вычисления подзапроса НЕ пуст\nрезультат вычисления подзапроса пуст\nникогда\n\n\n",
    "question": " В каких случаях атомы предикаты принимают значения true false и unknown?",
    "question_number": 44
  },
  {
    "answer": "\nСравнения, between, exists, in, like, null и предикат с квантором\n(кванторы бывают all, some).\n",
    "question": " Какие виды атомов предикатов предусмотрены в стандарте SQL для логического выражения условия поиска?",
    "question_number": 45
  },
  {
    "answer": "\nВозможный случай\nПояснение\nПример\nНаличие в выражении GROUP BY без HAVING\nРезультатом этого раздела является разбиение таблицы на множество групп строк, в которых для каждого столбца из списка столбцов раздела GROUP BY во всех строках каждой группы, значения этого столбца совпадают\nSELECT COUNT(reg_number), gender\nFROM Patients\nGROUP BY gender;\n\nпосчитать кол-во пациентов определенных полов\nНаличие HAVING без GROUP BY\nРезультатом выполнения выражения будет либо пустая таблица, либо результат выполнения предыдущих разделов табличного выражения, рассматриваемых как одна группа без столбцов группировки\nSELECT birthdate, gender\nFROM Patients\nHAVING birthdate > \"19990101\";\n\nвывести Д\\Р и пол пациентов, родившихся позже 1-го января 1999-го года\n(тут HAVING работает как WHERE, только в конечном итоге результат будет рассматриваться как одна группа)\nНаличие GROUP BY и HAVING\nРезультатом выполнения раздела HAVING является сгруппированная таблица,\nсодержащая только те группы строк, для которых результат вычисления условия поиска\nверен.\n\n\nSELECT COUNT(reg_number), birthdate\nFROM Patients\nGROUP BY birthdate\nHAVING birthdate > \"19990101\";\n\nпосчитать кол-во пациентов определенных дней рождения и вывести значения для дат позже 1 января 1999 года\n\n",
    "question": " Перечислите и поясните все случаи при которых вычисление табличного выражения приведет к сгруппированной таблице",
    "question_number": 46
  },
  {
    "answer": "\nВ выражениях предикатов, входящих в условие выборки раздела HAVING прямо можно использовать только спецификации столбцов, указанных в качестве группирования в разделе GROUP BY. Остальные столбцы можно использовать только внутри спецификаций агрегатных функций COUNT, SUM, AVG, MIN, MAX, вычисляющих в данном случае некоторое агрегатное значение для всей группы строк.\nАналогично обстоит дело с подзапросами, входящими в предикаты условия выборки раздела HAVING: если в подзапросе используется характеристика текущей группы, то она может задаваться только путем ссылки на столбцы группирования.\n\n",
    "question": " Какие дополнительные ограничения накладываются на условие поиска раздела HAVING по сравнению с условием поиска раздела WHERE? (4.2.4, стр. 44)",
    "question_number": 47
  },
  {
    "answer": "\nВ таблице, R - результат табличного выражения\nСлучай\nПояснение\nПример\nR не является сгруппированной таблицей\nПоявление хотя бы одной агрегатной функции от множества строк R в списке выборки приводит к тому, что R неявно рассматривается как сгруппированная таблица с отсутствующими столбцами группирования.\nПоэтому в списке выборки не допускается прямое использование спецификаций столбцов R: все они должны находиться внутри спецификаций агрегатных функций.\nРезультат запроса: таблица, состоящая не более чем из одной строки, полученной путем применения агрегатных функций к R\n\n\nSELECT COUNT(*)\nFROM Patients;\n\nПосчитать кол-во пациентов.\nрезультат - единственная строка с кол-вом пациентов.\nR - сгруппированная таблица, но табличное выражение не содержит GROUP BY и имеет HAVING\nВыборка формируется только с указанием столбцов внутри спецификаций агрегатных функций, т.к. результат табличного выражения явно объявлен сгруппированной таблицей.\nРезультат запроса - таблица из не более чем одной строки, полученной путем применения агрегатных функций к R\nSELECT COUNT(T.gender)\nFROM (\n    SELECT birthdate, gender\n    FROM Patients\n    HAVING birthdate > \"19990101\"\n) T; ЧЕ ЗА БРЕД??\nR - сгруппированная таблица, табличное выражение имеет GROUP BY и хотя бы один столбец группирования\nДопускается прямое использование имен столбцов группирования, имена остальных столбцов R могут появляться только внутри агрег. функций.\nРезультат - таблица, число строк в которой равно числу групп в R, каждая строка формируется на основе значений столбцов группирования и агрег. функций.\nSELECT COUNT(reg_number), gender\nFROM Patients\nGROUP BY gender;\n\nпосчитать кол-во пациентов определенных полов\n\n",
    "question": " Укажите различные случаи применения агрегатных функций в списке выборки в зависимости от вида табличного выражения. (4.2.4, стр. 45-46) нужны примеры",
    "question_number": 48
  },
  {
    "answer": "\nЗадача: Выбрать подходящую логическую структуру для заданного массива данных, которые требуется поместить в базу данных. Иначе говоря, нужно решить вопрос, какие необходимы базовые отношения и какой набор атрибутов они должны включать. Другой важной задачей является обеспечение целостности данных, которая решается введением в схему БД ограничений целостности.\n\nЦели:\n1) Возможность хранения всех необходимых данных в БД.\n2) Исключение избыточного дублирования данных.\n3) Сведение числа хранимых в БД отношений к минимуму.\n4) Нормализация отношений для упрощения решения проблем, связанных с вставкой, обновлением и удалением данных.\n",
    "question": " Как формулируется задача проектирования реляционной базы данных? Какие цели при этом преследуются?",
    "question_number": 49
  },
  {
    "answer": "\nУниверсальное отношение - это отношение, в которое включаются все представляющие интерес атрибуты ПрО. И которое может таким образом содержать все данные, предполагающие к хранению в БД. Для малых БД (включающих не более 15-20 атрибутов) универсальное отношение может использоваться в качестве отправной точки при проектировании РБД.\n\n",
    "question": " Что такое универсальное отношение?",
    "question_number": 50
  },
  {
    "answer": "\nАномалии вставки, удаления, обновления.\n\n\n",
    "question": " Какие аномалии могут возникать при использовании некачественных отношений? ",
    "question_number": 51
  },
  {
    "answer": "\nОтношение находится в первой нормальной форме, если все его атрибуты атомарны, то есть если ни один из его атрибутов нельзя разделить на более простые атрибуты, которые соответствуют каким-то другим свойствам описываемой сущности.\n\n",
    "question": " Укажите условие первой нормальной формы отношений.",
    "question_number": 52
  },
  {
    "answer": "\n\nДекомпозиция - процесс разбиения отношения, с целью уменьшения\nвероятности возникновения аномалий.\n(Декомпозиция отношения R - замена R на совокупность отношений {R1, R2,… , Rn} такую, что каждое из них есть проекция R, и каждый атрибут R входит хотя бы в одну из проекций декомпозиции.)\n\n",
    "question": " Что такое декомпозиция отношения? Для чего используется декомпозиция?",
    "question_number": 53
  },
  {
    "answer": "\nС помощью операции проекции. Каждое из получаемых в результате декомпозиции отношений в действительности является проекцией исходного отношения. ???\n\n",
    "question": " С помощью какой операции над отношениями она осуществляется?",
    "question_number": 54
  },
  {
    "answer": "\nПростым правилом выбора ФЗ для декомпозиции может служить поиск цепочек ФЗ вида A -> B -> C (A функционально определяет B, B функционально определяет C) с последующим использованием крайней правой зависимости.\nБолее обобщенно: всеми средствами следует избегать выбора ФЗ, зависимая часть которой сама – целиком или частично – является детерминантом другой ФЗ.\n\n",
    "question": "Каких правил следует придерживаться при выборе Функциональной зависимости для очередной декомпозиции? (4.2.5, стр. 19)",
    "question_number": 55
  },
  {
    "answer": "\n\nОперация соединения.\nЕсли оператором декомпозиции в процедуре нормализации является операция\nпроекции, то обратной операцией служит операция соединения.\n\n",
    "question": " Какая операция является обратной декомпозиции?",
    "question_number": 56
  },
  {
    "answer": "\n1) Если даны два атрибута A и B, то говорят, что B функционально зависит (ФЗ) от A, если для каждого значения A в любой момент времени существует не более одного связанного с ним значения B. A и B могут быть составными. Говорят еще, что A функционально определяет B.\n2) Функциональное отображение между атрибутами A и B.\n3) Единственным способом для получения информации о  функциональных зависимостей для схемы отношения заключается в том, чтобы внимательно проанализировать семантику атрибутов. В этом смысле зависимости являются фактически высказываниями о закономерностях реального мира. ???\n\n",
    "question": " Как в теории реляционных БД определяется функциональная зависимость ФЗ? Какое отображение стоит за этим понятием? Что является источником информации о ФЗ? (4.2.5, стр. 9)",
    "question_number": 57
  },
  {
    "answer": "\n\nЕсли А -> В ( A функционально определяет B) и В не зависит функционально от любого подмножества А, то говорят, что А представляет собой детерминант В.\n\n",
    "question": " Что такое детерминант атрибута?",
    "question_number": 58
  },
  {
    "answer": "\n\nВозможный ключ отношения - атрибут или набор атрибутов, который может быть использован для данного отношения в качестве первичного ключа. (UNIQUE)\nВозможный ключ (потенциальный ключ, ключ-кандидат) – это\n1) Атрибут (группа атрибутов) отношения, который функционально определяет все другие атрибуты этого отношения.\n2) Атрибут (группа атрибутов) отношения, который функционально определяет отношение.\n3) Атрибут (группа атрибутов) отношения, который не имеет значений-дубликатов в кортежах отношения.\n\n",
    "question": " Что такое возможный ключ отношения?",
    "question_number": 59
  },
  {
    "answer": "\nОтношение находится в нормальной форме Бойса-Кодда (НФБК), если каждый детерминант атрибутов отношения является возможным ключом отношения.\n\n4.2, 164-173\n",
    "question": " Определите условие нормальной формы Бойса Кодда (НФБК). (нормальной формы Бойса Кодда)",
    "question_number": 60
  },
  {
    "answer": "\n1. Разработка универсального отношения для БД и преобразование его в 1НФ (первую нормальную форму).\n2. Определение всех ФЗ очередного отношения.\n3.Определение того, находится ли очередное отношение в НФБК. Если да, то проектирование для него завершается, если нет – это отношение декомпозируется на два новых, которые помещаются в очередь еще не проверенных на НФБК отношений.\n4. Повторение шагов 2 и 3 для каждого очередного отношения. Проектирование завершается, когда очередь еще не проверенных на НФБК отношений опустеет, а, значит, все полученные отношения находятся в НФБК.\n\n",
    "question": " Приведите первоначальный алгоритм нормализации отношений до НФБК.  (нормальной формы Бойса Кодда) ",
    "question_number": 61
  },
  {
    "answer": "\nСоединение без потерь: декомпозиция обладает свойством соединения без потерь, если она позволяет восстановить любой кортеж исходного отношения, используя соответствующие кортежи меньших отношений, полученных в результате декомпозиции.\nСохранение зависимостей: декомпозиция называется сохраняющей зависимости, если зависимости исходного отношения сохранены в новой схеме отношений.\nБолее подробно: декомпозиция называется сохраняющей зависимости, если замыкание соединения всех подмножеств функциональных зависимостей меньших отношений соответствует замыканию исходного множества ФЗ.\n\n",
    "question": " Укажите желательные свойства декомпозиции. Дайте им определения.",
    "question_number": 62
  },
  {
    "answer": "\nВ основе метода синтеза лежит утверждение о том, что необходимо все функциональные зависимости с одинаковыми детерминантами выделить в группы и для каждой группы построить свое отношение, куда включить все атрибуты всех функциональных зависимостей этой группы.\nПример: когда атрибут зависит от двух различных детерминантов:\nR(A, C, B)\nA->B, C->B\nПри использовании метода декомпозиции для одной из зависимостей, другая неизбежно теряется:\nR1(A, C) и R2(A, B) => C->B утеряна\nR1(A, C) и R2(C, B) => A->B утеряна\nЕсли воспользоваться методом синтеза и для каждого детерминанта A и B определить группу зависимых атрибутов и построить свое отношение:\nR1(A, B) и R2(C, B) => оба отношения находятся в НФБК (нормальная форма Бойса Кодда), все зависимости сохранены\n\n",
    "question": " В чем заключается метод синтеза? Приведите пример.",
    "question_number": 63
  },
  {
    "answer": "\nЗависимость, не заключающая в себе такой информации, которая не могла бы быть получена на основе других зависимостей из числа использованных при проектировании БД.\n\n",
    "question": " Что такое избыточная ФЗ (Что такое избыточная функциональная зависимость)? ",
    "question_number": 64
  },
  {
    "answer": "\nРефлективность, Пополнение, Транзитивность, Объединение, Декомпозиция, Псевдотранзитивность.\n\nРефлективность указывает, что множество атрибутов всегда функционально определяет любое из своих подмножеств.\nПополнение указывает, что добавление одного и того же множества атрибутов и к левой, и к правой частям функциональной зависимости (или только к левой) приводит к получению еще одной действительной зависимости.\nТранзитивность указывает, что функциональные зависимости являются транзитивными.\nДекомпозиция определяет, что можно удалять атрибуты из правой части зависимости.\nОбъединение указывает, что в процессе проектирования может быть выполнена обратная операция, при которой ряд зависимостей с одинаковыми левыми частями А -> В, А -> С и A -> D объединяется в одну функциональную зависимость А -> В, С, D.\n\n\n\n\n",
    "question": " Перечислите правила вывода ФЗ (правила вывода функциональной зависимости).",
    "question_number": 65
  },
  {
    "answer": "\nНадежность и полнота.\nНадежность: если зависимость выведена из некоторого набора при помощи аксиом, то она справедлива для любого отношения, для которого справедлив исходный набор.\nПолнота: все функциональные зависимости, производные для некоторого исходного множества, можно вывести из этого множества только при помощи этих аксиом.\nАксиомы - рефлективность, пополнение, транзитивность.\n\n(Аксиомы Армстронга - это набор ссылок (или, точнее, правил вывода), используемых для вывода всех функциональных зависимостей реляционной базы данных)\n",
    "question": " Какими свойствами обладают аксиомы Армстронга?",
    "question_number": 66
  },
  {
    "answer": "\nЕсли некоторая функциональная зависимость может быть выведена из других ФЗ с помощью этих правил, то она избыточна.\nПример: пусть справедливы зависимости А -> В, А -> С и А -> В, С. Из правила объединения мы знаем, что зависимость А -> В, С следует из А -> В и А -> С, следовательно, она избыточна.\n\n\n\n",
    "question": " Как определять избыточные ФЗ с использованием правил вывода ФЗ? Приведите пример.",
    "question_number": 67
  },
  {
    "answer": "\nНабор неизбыточных ФЗ (функциональных зависимостей), полученный путем удаления всех избыточных ФЗ из исходного набора с помощью правил вывода.\n\n",
    "question": " Что такое минимальное покрытие ФЗ отношения?",
    "question_number": 68
  },
  {
    "answer": "\nПостроение универсального отношения.\nОпределение всех ФЗ (функциональных зависимостей), существующих между атрибутами этого отношения.\nУдаление всех избыточных ФЗ из исходного набора ФЗ с целью получения минимального покрытия.\nИспользование ФЗ из минимального покрытия для декомпозиции универсального отношения в набор НФБК-отношений.\nОпределение ФЗ минимального покрытия для очередного отношения.\nОпределение того, находится ли очередное отношение в НФБК. Если да, то проектирование для него завершается, если нет – это отношение декомпозируется на два новых, которые помещаются в очередь еще не проверенных на НФБК отношений.\nПовторение шагов 4.1 и 4.2 для каждого очередного отношения. Проектирование завершается, когда очередь еще не проверенных на НФБК отношений опустеет, а, значит, все полученные отношения находятся в НФБК.\nЕсли может быть построено более чем одно минимальное покрытие, осуществляется сравнение результатов, полученных на основе этих минимальных покрытий, с целью определения варианта, лучше других отвечающего требованиям ПрО.\n\n",
    "question": " Как окончательно выглядит декомпозиционный алгоритм проектирования реляционных схем БД?",
    "question_number": 69
  },
  {
    "answer": "\nСоставляются списки ФЗ (функциональных зависимостей) для каждого отношения. Списки проверяются по двум направлениям:\nОдна и та же ФЗ не должна появляться более чем в одном отношении.\nНабор ФЗ, полученный в результате проектирования, должен в точности совпадать с набором, присутствующем в минимальном покрытии, полученном перед началом проектирования. В противном случае, необходимо показать возможность получения итогового набора ФЗ из минимального покрытия с помощью правил вывода и наоборот.\nОсуществляется проверка на присутствие избыточных отношений. Если устанавливается избыточность отношения, его следует исключить из проектного набора. Отношение является избыточным, если:\nвсе атрибуты этого отношения могут быть найдены в одном другом отношении проектного набора.\nвсе атрибуты этого отношения могут быть найдены в отношении, которое может быть получено из других отношений проектного набора с помощью серии операций соединения над этими отношениями.\nОтношения рассматриваются с практической точки зрения. Изучается характер использования отношений в конструируемой БД и определяется, будут ли они обеспечивать те типы запросов и операций обновления, которые предполагается выполнять.\n\n\n\nГлоссарий:\n1Правила вывода: (-> читается как определяет)\n\n\n1ФЗ - функциональная зависимость\n\n1НФБК - нормальная Форма Бойса-Кодда. Отношение находится в нормальной форме Бойса-Кодда (НФБК), если каждый детерминант атрибутов отношения является возможным ключом отношения.\n\n1Детерминант - Если А->B (A функционально определяет B) не зависит функционально от любого подмножества А, то А представляет собой детерминант B\n\n1Возможный ключ, 1Ключ-кандидат, 1Потенциальный ключ - Атрибут (группа атрибутов), функционально определяющее отношение.\n\n1Суперключ - атрибут или их множество, единственным образом идентифицирующее кортеж отношения.\n\n1Потенциальный ключ - суперключ, никакое подмножество которого не является суперключом.\n\n1Составной ключ - ключ, состоящий из нескольких атрибутов.\n\n1Первичный ключ - потенциальный ключ, выбранный для уникальной идентификации кортежей отношения.\n\n1Альтернативный ключ - потенциальный ключ, не выбранный в качестве первичного.\n\n1Суррогатный ключ - искусственный атрибут, не имеющий связей с реальными характеристиками явлений ПрО, вводимый в схему отношения исключительно для организации связи кортежей.\n\n1Суррогатный первичный ключ - первичный ключ, уникальные значения которого генерируются СУБД.\n\n1Внешний ключ - атрибут отношения или множество атрибутов, соответствующее потенциальному ключу некоторого отношения и являющееся его подмножеством.\n\"внешний ключ должен являться подмножеством значений атрибутов на которые он ссылается\"\n\n1Триггер – это программа на языке программирования сервера, которая автоматически выполняется СУБД в момент наступления определенного события.\n\n1Курсор - инструмент для построчного сканирования результирующих таблиц с данными.\n\n1unknown (1ановн, 1анновн, 1анкновн, 1анноун, 1аноун, 1анкноун) - третье значение логического типа, обладающее свойствами: (для удобства запоминания можно представлять unkn0wn = 0.5, true = 1, false = 0)\n\n1Кортеж – набор именованных значений заданных типов (это множество пар «имя атрибута, значение», которое содержит одно вхождение каждого имени атрибута, принадлежащего схеме отношения).\n\n1Тип данных - понятие, аналогичное понятию в языках программирования (т.е. множество значений и операций над ними)\n\n1Домен - множество допустимых значений данного типа.\n\n1Атрибут - именованный домен, представляющий семантически значимые объекты.\n\n1Отношение - множество кортежей, соответствующих одной схеме отношения.\n\n1Схема отношения – это именованное множество пар «имя атрибута, имя домена».\n\n1Схема БД – это набор именованных схем отношений.\n\n1Мощность множества - степень схемы отношения\n\n1Представление - виртуальное отношение, кортежи (или экстенсионал) которого не хранятся на диске, а воспроизводятся на основании базовых отношений, реально существующих в БД.\n\n1Аксиомы Армстронга - это набор ссылок (или, точнее, правил вывода), используемых для вывода всех функциональных зависимостей реляционной базы данных\n\n1Универсальное отношение - это отношение, в которое включаются все представляющие интерес атрибуты ПрО. И которое может таким образом содержать КАк в все данные, предполагающие к хранению в БД. Для малых БД (включающих не более 15-20 атрибутов) универсальное отношение может использоваться в качестве отправной точки при проектировании РБД.\n",
    "question": "Какие проверки отношений следует провести на завершающей фазе проектирования?",
    "question_number": 70
  }
]
